<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Simple Game Graphics Library: Bitmap Manipulation</title>
<link rel="icon" href="libicon.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="libicon.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Simple Game Graphics Library<span id="projectnumber">&#160;1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Bitmap Manipulation </div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab4a4fbd8bd184a28472869f942d19b15" id="r_gab4a4fbd8bd184a28472869f942d19b15"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4a4fbd8bd184a28472869f942d19b15">preloadBitmaps</a> (const std::string &amp;dir)</td></tr>
<tr class="memitem:gaee9c316b576d7ae4d36b38a4b1fb4d93" id="r_gaee9c316b576d7ae4d36b38a4b1fb4d93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee9c316b576d7ae4d36b38a4b1fb4d93">getBitmapData</a> (const std::string &amp;bitmap_name, unsigned char **buffer, unsigned int *width, unsigned int *height)</td></tr>
<tr class="memitem:ga7db17ee80358f7c009beffe0c8efa4ec" id="r_ga7db17ee80358f7c009beffe0c8efa4ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7db17ee80358f7c009beffe0c8efa4ec">updateBitmapData</a> (const std::string &amp;bitmap_name, const unsigned char *buffer)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gaee9c316b576d7ae4d36b38a4b1fb4d93" name="gaee9c316b576d7ae4d36b38a4b1fb4d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee9c316b576d7ae4d36b38a4b1fb4d93">&#9670;&#160;</a></span>getBitmapData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getBitmapData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bitmap_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the internally stored image buffer of the bitmap, along with the width and height of the internally stored image.</p>
<p>The size of the image buffer is not necessarily the same with that of the requested bitmap to load, since SGG internally makes the image dimensions powers of two. The reported width and height are therefore the corrected dimensions. The image can be used for obtaining the data to a bitmap used as texture in the engine and modify its contents. The number of channels in the image buffer are always expected to be 4 (red, green, blue and opacity - alpha). <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_name</td><td>is the name of the bitmap as loaded and indexed by SGG.</td></tr>
    <tr><td class="paramname">buffer</td><td>is a pointer to an unsigned char array to pass the internal address of the image buffer to. Warning, the data can be directly modified.</td></tr>
    <tr><td class="paramname">width</td><td>is a pointer to an unsigned int variable to store the width of the image buffer.</td></tr>
    <tr><td class="paramname">height</td><td>is a pointer to an unsigned int variable to store the height of the image buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested bitmap was located and its data were successfully retrieved, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga7db17ee80358f7c009beffe0c8efa4ec">updateBitmapData</a> </dd></dl>

</div>
</div>
<a id="gab4a4fbd8bd184a28472869f942d19b15" name="gab4a4fbd8bd184a28472869f942d19b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4a4fbd8bd184a28472869f942d19b15">&#9670;&#160;</a></span>preloadBitmaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; preloadBitmaps </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads all PNG bitmaps located in a directory specified by the argument dir at once.</p>
<p>Preloading image assets prior to actually requesting a draw call with a brush that uses them can significantly boost performance during the typical draw call when a bitmap is first used.</p>
<p>When a named image is used for a brush, the first time the library encounters the image asset with the specific unique name, it attempts to load the image, scale the bitmap to the closest power of two (if not already in the right resolution) and create the necessary internal representation for the underlying graphics API. For large assets, this process can take some time, noticeable as momentary freeze and general slowdown, depending on the size and number of images needed to be loaded. This of course happens only the first time a bitmap is used in the application, but can nevertheless degrade the user experience.</p>
<p>preloadBitmaps performs the above process in bulk, for all PNG bitmaps found in the provided directory. This can be done during the application initialization stage, before the actual main interaction loop begins. The function can be called multiple times for a different directory each time, to progressively load organized collections of bitmaps. preloadBitmaps returns a vector of the bitmaps successfully loaded, which can be used as a means to validate that all assets have been properly loaded. Another useful application of the function is to load multiple bitmaps without the need to know the specific names beforehand. For example, one can organize the frames of an animation sequence into a separate folder and load all the sequence at once, maintaining the animation bitmap names for reference and cycling over the animation sequence. Another different application example is the call of the function on a directory to discover and load all images contained there to be able to list and preview the images during runtime (e.g. in an image viewer application).</p>
<p>The preloadBitmaps function can be called at any time after the graphics initialization, i.e. after the call to createWindow.</p>
<p>Please note that since a bitmap is identified by its fully qualified path, bitmaps with the same filename residing in different directories are treated as two different assets. Also note that multiple attempts to preload the same bitmap will report the bitmap as successfully loaded in the return vector, but the actual bitmap loaded the first time will be used and will not be replaced by the loader in subsequent calls. This means that during runtime, even if one modifies the bitmap asset externally and explicitly calls preloadBitmaps (or any other bitmap loading via a new brush creation), the original bitmap loaded the first time will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>is the directory of the bitmaps to preload. Only PNG images will be loaded (extension is case-insensitive) and all other files in the directory will be ignored. The function is not called recursively for contained sub-directories.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the full path names to the individual bitmaps identified and successfully loaded. The path names will include the directory name given. </dd></dl>

</div>
</div>
<a id="ga7db17ee80358f7c009beffe0c8efa4ec" name="ga7db17ee80358f7c009beffe0c8efa4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db17ee80358f7c009beffe0c8efa4ec">&#9670;&#160;</a></span>updateBitmapData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool updateBitmapData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bitmap_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the internally stored image buffer data of a bitmap.</p>
<p>The function passes an image buffer to SGG to replace the data of an existing bitmap. The expected dimensions of the buffer can be obtained using the getBitmapData function. The number of channels in the image buffer are always expected to be 4 (red, green, blue and opacity - alpha). The size of the image buffer is not necessarily the same with that of the requested bitmap to load, since SGG internally makes the image dimensions powers of two. The reported width and height are therefore the corrected dimensions. The image can be used for obtaining the data to a bitmap used as texture in the engine, modify its contents and update it using the updateBitmapData function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_name</td><td>is the name of the bitmap as loaded and indexed by SGG.</td></tr>
    <tr><td class="paramname">buffer</td><td>is an unsigned char array to copy the image data from. If nullptr, no pixel copy is performed, but the texture is nevertheless rebuilt. This is useful for reloading the internal image buffer to the graphics back end, after directly modifying the texture data using the pointer returned by getBitmapData.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the requested bitmap was located and its data were successfully updated, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gaee9c316b576d7ae4d36b38a4b1fb4d93">getBitmapData</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
